\chapter[Positionsregelung]{Verifizierung der Positionsregelung der ETH-Zürich in Verbindung mit einem Laserscanner}
\label{chap:Positionsregelung}
\begin{figure}
	\centering
	\includegraphics[width = .95\textwidth]{images/ros_hl_interf_hl_frame}
	\caption[AscTec\_hl\_framework in der Kommunikationstruktur]{AscTec\_hl\_framework in der Kommunikationstruktur }
	\label{fig:asctechlfrkom}
\end{figure}

In Zusammenarbeit von \gls{asctec} und der ETH-Zürich ist ein Regler zur Positionierung des Pelican Quadrocopters in geschlossenen Räumen entwickelt und veröffentlicht worden. Der Entwurf basiert auf einer monokularen Kamera, die mittels eines \gls{vslam}-Algorithmus und der Fusion der \gls{imu} die Position des Flugobjekts in einer unbekannten Umgebung ermitteln kann. Die dazugehörigen Regelung- und Fusionsalgorithmen sind im Paper \cite{Achtelik11} beschrieben. Diese stehen als asctec\_hl\_framework zum Download \cite{asctecframework}  zur Verfügung und wurden im Rahmen dieser Arbeit auf den \gls{hlp} geladen (Abbildung \ref{fig:asctechlfrkom}).

Aufgabe dieses Kapitel ist es die veröffentlichen \cite{Achtelik11} Annahmen und Formeln der Fusion und Regelung zu verifizieren. Dies erfolgt über Literaturrecherchen und Herleitung der publizierten Gleichungen. Unter Berücksichtigung, dass die Position nun mehr vom Laser über die in Kapitel \ref{chap:2Dpositionsbestimmung} vorgestellten Algortihmen bestimmt wird, ist Abschnitt \ref{sec:strukpositionsregelung} darauf ausgelegt eine Übersicht über die Bestandteile der Regelung zu geben. Die Herleitung der Komponenten erfolgt in den anschließenden Unterkapiteln. 


%*************************************************************************************************************************
\section[Aufbau]{Aufbau der Positionsregelung}
\label{sec:strukpositionsregelung}
Das Hauptaugenmerk dieses Unterkapitel liegt darauf, wie sich die Positionsregelung in die in Kapitel \ref{sec:Kommunikationsarchitekur} vorgestellte Systemstruktur einfügt. Welche Softwarekomponenten dafür auf dem \gls{hlp} integriert sind und wie die Kommunikation zwischen ihnen und der Umgebung aussieht. Ziel ist es ein grundlegendes Verständnis für die Funktionsweise der Regelung zu generieren.\\
\begin{figure}
	\centering
	\includegraphics[width = .95\textwidth]{images/Kaskadenstruktur}
	\caption[Kaskadenstruktur der Positionsregelung]{Kaskadenstruktur der vereinfachten Positionsregelung } %
	\label{fig:kaskstruc}
\end{figure}


Die Positionsregelung setzt auf der Lageregelung (engl. attitude control) auf. Daraus resultiert eine Kaskadenstruktur (Abbildung \ref{fig:kaskstruc}). Diese Vorgehensweise ist nachvollziehbar, da die Lageregelung bereits fest auf dem \gls{llp} implementiert ist. Diese besteht aus einem Regelalgorithmus, der anhand der Regeldifferenz der Orientierung $e_{ori}$, welche durch die Abweichung der Soll-Orientierung $O_{des}$ zu Ist-Orientierung $ O  $ resultiert, in Verbindung mit der Sollschubvorgabe $ T_s $ die Drehzahlen $ n_{1..4} $ der Rotoren berechnet und einstellt. Die Ist-Orientierung $ O =\begin{bmatrix} \phi&\theta&\psi\end{bmatrix}^T $ wird mittels eines Fusionsfilter bestimmt. Dieser fusioniert die Messwerte der auf der \gls{imu} befindlichen Gyroscope sowie der Beschleunigungssensoren mit den Daten des 3D-Kompasses. Wie dieser unterlagerte Regler und der dazugehörige Zustandsschätzer genau umgesetzt sind, ist nicht bekannt. Eine mögliche Ausführung ist in Paper \cite{hoffmann10} beschrieben. Die Ungewissheit über den Regleraufbau der Lageregelung stellt für den Entwurf der überlagerten Positionsregelung keine Problematik dar. Von Interesse ist lediglich, dass die Annahme einer sehr hohen Dynamik dieses Reglers zur einer Vereinfachung des für die Positionsregelung benötigen Modells (Kapitel \ref{sec:Modelbildung}) führt. Hohe Dynamik bedeutet, dass der Sollwinkel in einer sehr kurzen Zeit $ t \rightarrow 0~s $ erreicht wird. Basierend auf einer exakten Zustandslinerarisierung (Kapitel \ref{sec:exkt.zstdlin}) der inneren Schleife in Verbindung mit dem Translationsmodell, ist die äußere Reglerschleife zur Positionsregelung auf dem \gls{hlp} realisiert. Dank der Inversion, entsprechend dem Stellgesetz der exakten Zustandslinearisierung, kann für die Positionierung des Quadrocopters eine lineare Zwei-Freiheitsgraderegelung (Abbildung~\ref{fig:zweifgr}) angewandt werden.
\begin{figure}
	\centering
	\includegraphics[width = .95\textwidth]{images/2-FHG-R}
	\caption[Struktur Zwei-Freitheitsgraderegelung]{Struktur einer Zwei-Freiheitsgraderegelung} %
	\label{fig:zweifgr}
\end{figure} 
Diese besteht aus einer Vorsteuerung und einem Folgeregler. Die Vorsteuerung auf dem \gls{hlp} ist in Form eines Referenzmodells (Kapitel \ref{sec:referenzmodell}), das dem linearisierten Modell nachempfunden ist, ausgeführt. Anhand der vorgegebenen Soll-Position $P^n_{des} = \begin{bmatrix} x&y&z\end{bmatrix}^T_{des} $ wird eine Referenz-Trajektorie \footnote{Trajektorien beschreiben einen zeitabhängigen Verlauf eines Wertes in einem Bezugssystem} zur Überführung des Quadrocopters aus der aktuellen Ist-Position in die Soll-Position berechnet. Ergebnis ist ein Stellwert für die Inversion, der unter theoretischer Betrachtung die gewünschte Bahnbewegung des Quadrocopters zur Folge hat. In einem realen System ist dies durch Einflüsse aus der Umgebung (bspw. Wind) nicht gewährleistet. Deshalb ist zusätzlich der Folgeregler (Kapitel \ref{sec:folgeregeler}) implementiert. Dessen Aufgabe besteht darin Abweichungen der realen Zustände des Quadrocopters von den Referenzwerten auszuregeln. Die dafür benötigten Zustandsgrößen des Flugsystems (Kapitel \ref{sec:Zustandsbestimmung}) werden durch die Fusion der über Laser bestimmten Position (Kapitel \ref{chap:2Dpositionsbestimmung}) sowie den Beschleunigungswerten der \gls{imu} bestimmt.

Bevor jede einzelne Komponente in den folgenden Kapiteln hergeleitet wird, ist in Abbildung~\ref{fig:strucregelung} die Verknüpfung aller Komponenten grafisch dargestellt.
\begin{figure}
	\centering
	\includegraphics[width = .85\textwidth]{images/Reglerstruktur}
	\caption[Struktur der Positionsregelung]{Struktur der Positionsregelung (asctec\_hl\_framework) \cite{Achtelik11}} %
	\label{fig:strucregelung}
\end{figure}


Anzumerken ist, dass die in Verbindung mit \gls{asctec} entworfene Positionsregelung zur Ausrichtung des Quadrocopters in einem dreidimensionalen Raum entwickelt ist. Für die vertikale Positionierung ist bereits in der vorausgegangenen Arbeit \cite{JanKal13} von Jan Kallwies eine Regelung beschrieben. Da diese Regelung Effekte, wie den Groundeffekt \footnote{In Bodennähe verhindert der Untergrund das schnelle Abströmen des durch die Rotoren erzeugten Luftstroms. Die daraus resultierende Krafterhöhung bei gleichbleibender Drehzahl der Rotoren, wird als Groundeffekt bezeichnet. } berücksichtigt, ist es die Aufgabe eines auf diese Arbeit folgenden studentischen Projektes, selbige in das System der ETH-Zürich einzupflegen. Dadurch reduziert sich die Validierung der Reglerstruktur auf die horizontale Ebene. 

 

%*************************************************************************************************************************

\section[Modellbildung]{Herleitung des kinematischen Modells}
\label{sec:Modelbildung}
Die Modellbildung ist die Grundlage für den systematischen Entwurf einer Zustandsregelung. Dabei wird das Systemverhalten in Form von Differentialgleichungen abgebildet. Diese beschreiben die zeitliche Veränderung einer Ausgangsgröße in Abhängigkeit ihrer zeitlichen Ableitungen sowie veränderlichen Eingangsgrößen. So lassen sich unter Beachtung der physikalischen Gesetze Bewegungsgleichungen aufstellen, welche das räumliche und zeitliche Verhalten eines mechatronischen Systems abbilden. 

Bevor die Bewegungsgleichungen des Quadrocopters aufgestellt werden können, ist es notwendig, die Freiheitsgrade des dynamischen Systems gegenüber dem Bezugssystem zu bestimmen. Da zwischen dem n-frame (Bezugssystem) und dem b-frame (Quadrocopter) keine mechanische Verbindung oder konstante Koordinatentransformation existiert, besitzt das Flugsystem sechs Freiheitsgrade, bestehend aus drei rotativen $\begin{bmatrix} \phi&\theta&\psi\end{bmatrix}^T$ und drei translatorischen $\begin{bmatrix} x&y&z\end{bmatrix}^T$. Sechs Freiheitsgrade sind gleichzusetzen mit sechs Differentialgleichungen zur Beschreibung der Bewegung im Raum. Damit sind nicht alle Dynamiken des Systems abgebildet. So sind zur Darstellung des Gesamtsystems weitere Differentialgleichungen aufzustellen. Zum einen ist hier die Dynamik der Elektromotoren einzukalkulieren, die die Rotoren antreiben. Des Weiteren auch die durch die Rotation der Rotorblätter ausgelöste Schubentwicklung nach den Gesetzen der Strömungslehre. Unter Beachtung aller Aspekte entsteht eine mathematisch meist nichtlineare und komplexe Systembeschreibung. Da mit zunehmender Größe des Modells auch die Fehleranfälligkeit steigt, wird in der Modellbildung folgender Leitsatz wiederholt aufgeführt. \glqq Ein Modell sollte das zu regelende Verhalten so einfach wie möglich und so detailliert wie nötig darstellen.\grqq  ~Wird die Struktur der implementierten Flugregelung (Abbildung \ref{fig:strucregelung}) betrachtet, reduziert sich das Modell aus Sicht der Positionsregelung erheblich. Grund hierfür ist die in Abbildung \ref{fig:kaskstruc} dargestellte Kaskadenstruktur der Regelung. In Verbindung mit Abbildung \ref{fig:strucregelung} ist zu erkennen, dass der Lageregelung als Eingangsgrößen eine Soll-Orientierung $ O_{des} =\begin{bmatrix} \phi&\theta&\psi\end{bmatrix}^T $ und eine Schubvorgabe $T_{des}$ übergeben wird. Aus Sicht der Positionsregelung sind das auch die Eingänge des zu regelnden Modells. Fest steht, dass sowohl die rotative Dynamik als auch die Schubentwicklung über den auf dem \gls{llp} befindliche Regler eingestellt wird. Dieser ist ab Werk so gut parametriert, dass die Zeitkonstante zwischen Vorgabe und Einstellen des Sollwerts sehr gering ist. Dies wurde durch einen Versuch bestätigt. Da der Aufbau der Lageregelung nicht bekannt ist, wurde dazu das experimentelle Systemidentifikationstool von Manfred Ottens \cite{sysindent} herangezogen. Um die Zeitkonstante schätzen zu können, wird das Übertagungsverhalten von Ist- zu Soll-Winkel als PT1-Glied abstrahiert. Die Zeitkonstante T wird aus den Messdaten des Sollwertes und des Istwertes ermittelt. Dabei ergibt das Mittel über mehrere Messungen eine Zeitkonstante von T$\approx0.1~s$. Mit der Gewissheit, dass die Dynamik der Positionsregelung um ein vielfaches geringer ausfällt, ist beim Entwurf die Zeitkonstante T dieser Regelung zu vernachlässigen. In Folge entspricht  Soll- gleich Ist-Winkel.
 \begin{equation}
  O_{des} = O = \begin{bmatrix} \phi&\theta&\psi\end{bmatrix}^T
 \end{equation}
     
Somit reduziert sich die für die Positionsregelung zu modellierende Dynamik auf die translatorischen Differenzialgleichungen. Um zur Bestimmung dieser die Newtonsche Gesetze anwenden zu können, werden diese im n-frame definiert. Dabei kann der Quadrocopter als widerstandsfreie Kugel im dreidimensionalen Raum des Navigationskoordinatensystems abgebildet werden. Auf diese wirkt parallel zur z-Achse des n-frames die Gravitationskraft $ F^n_g $ und der in Richtung der $ z^b $-Achse angreifende Gesamtschub $ T $ (Gleichung \ref{eq:Schubvektor}) der Rotoren. Letztgenannte Kraft wird zur Anwendung der Newtonischen  Gesetze \cite{physik} in Kraftkomponenten des n-frames zerlegt (Abbildung \ref{fig:F_nframe}).
\begin{figure}
	\centering
	\includegraphics[width = .85\textwidth]{images/Force_nframe}
	\caption[Zerlegung des Schubvektors]{Zerlegung des Schubvektors in Kraftvektoren definiert im n-frame} %
	\label{fig:F_nframe}
\end{figure}     
Da die Dynamik der Lageregelung vernachlässigt wird, ist dies über eine einfache Koordinatentransformation vom b-frame ins n-frame realisierbar. Die entsprechende Transformation ist in Kapitel \ref{subsec:koordinatentransformation} in Formel (\ref{eq:inverse_transM}) eingeführt. Daraus ergibt sich:

\begin{equation}
 F^n =	\begin{bmatrix}
	F^n_x \\
	F^n_y \\
	F^n_z \\
	\end{bmatrix}
	=
	M_{nb} \cdot F^b - F_g 
	=
	M_{nb} \cdot 
	\begin{bmatrix}
	0 \\
	0 \\
	T \\
	\end{bmatrix}
	-
	\begin{bmatrix}
	0 \\
	0 \\
	F_g \\
	\end{bmatrix}
	\label{eq:superposF}
\end{equation} 
 
Nach dem zweiten Newtonschen Gesetz lässt sich die Beschleunigung $ a $ des Körpers bestimmen. Dieses besagt, eine Änderung der Bewegung resultiert proportional und geradlinig in Richtung der wirkenden Kraft. Dabei gilt die Beziehung: 
  
\begin{equation}
F^n =	\begin{bmatrix}
F^n_x \\
F^n_y \\
F^n_z \\
\end{bmatrix}
= m \cdot a = m \cdot	
\begin{bmatrix}
a^n_x \\
a^n_y \\
a^n_z \\
\end{bmatrix}
\label{eq:fma}
\end{equation} 

Für die konstante Masse $ m~(= 1.863~kg) $ des Quadrocoters lassen sich die Beschleunigungen des Körpers im dreidimensionalen Raum durch Einsetzen von (\ref{eq:superposF}) in (\ref{eq:fma}) berechnen.
\begin{equation}
\begin{bmatrix}
a^n_x \\
a^n_y \\
a^n_z \\
\end{bmatrix}
=
\frac{1}{m} \cdot (
M_{nb} \cdot 
\begin{bmatrix}
0 \\
0 \\
T \\
\end{bmatrix}
-
\begin{bmatrix}
0 \\
0 \\
F_g \\
\end{bmatrix}
)
\label{eq:beschl}
\end{equation}

Basierend auf dem Weg-Zeit-Gesetz \cite{physik} bestimmt sich für eine Anfangsgeschwindigkeit $ v^n_0  $ und eine Startposition $ P^n_0 $ die Position des Quadrocopters über die doppelte Integration der Beschleunigung aus (\ref{eq:beschl}).
\begin{equation}
\begin{split}
a^n &= \dot{v}^n = \ddot{P}^n\\
v^n &= \dot{a}^n = \int a^n dt + v^n_0\\
P^n &= \int v^n dt + P^n_0
\end{split}
\label{eq:weg-zeit}
\end{equation}

Mit diesen Gleichungen (\ref{eq:weg-zeit}) und (\ref{eq:beschl}) ist das translatorische Systemverhalten des Quadrocopters im n-frame mathematisch beschreibbar, abhängig von den Einganggrößen $ O_{des} $ und $ T_{des} $. Die resultierende Beschreibung der Zustände $ x =\begin{bmatrix}
v_x &
v_y &
v_z &
x &
y &
z 
\end{bmatrix}^T $ des Modells ergibt:
\begin{equation}
\begin{split}
\dot{x}_1 &= \frac{1}{m} \cdot ((\cos\phi\sin\theta\cos\psi+\sin\phi\sin\psi)\cdot T)\\
\dot{x}_2 &= \frac{1}{m} \cdot ((\cos\phi\sin\theta\sin\psi-\sin\phi\cos\psi)\cdot T)\\
\dot{x}_3 &= \frac{1}{m} \cdot ((\cos\phi\cos\theta)\cdot T)-g\\
\dot{x}_4 &= x_1\\
\dot{x}_5 &= x_2\\
\dot{x}_6 &= x_3\\
\end{split}
\label{eq:zstd}
\end{equation}
Zur Veranschaulichung ist das Modell zusätzlich in Abbildung \ref{fig:modstrukquad} visualisiert. 
\begin{figure}
	\centering
	\includegraphics[width = \textwidth]{images/modell_lage_trans}
	\caption[Kinematisches Modell]{Kinematisches Translationsmodell des Quadrocopters} %
	\label{fig:modstrukquad}
\end{figure}

 
Durch die Koordinatentransformation bzw. die trigonometrischen Funktionen ist die Systembeschreibung nichtlinear. Das bedeutet, dass von der Änderung der Eingangsgrößen keine direkte proportionale Änderung der Ausgangsgröße ableitbar ist. Somit ist eine direkte Ansteuerung der Lageregelung über einen linearen Positionsregler nicht möglich. Da allerdings ein linearer Regler vorgesehen ist, wird ein Baustein benötigt, der für fiktive Eingänge das Systemverhalten linearisiert.    

%%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\section[Inversion]{Zustandslinearisierung mittels Inversion}
\label{sec:exkt.zstdlin}
Zur Linearisierung eines nichtlinearen Modells wird in den Grundlagen der Regelungstechnik \cite{lunze08} die Arbeitspunktlinearisierung gelehrt. Nachteil einer solchen Linearisierung ist, dass sie oft nur Gültigkeit für eine kleine Umgebung um den Arbeitspunkt besitzt. Um mit dem Quadrocopter schnelle Positionswechsel vollziehen zu können, werden jedoch hohe Stellwinkel benötigt. Damit ist eine annähernde Linearisierung für einen Arbeitspunkt nicht ausreichend. Es ist eine Methode erforderlich, die das Modell über den gesamten Arbeitsbereich linearisiert. 
\begin{figure}
	\centering
	\includegraphics[width = \textwidth]{images/inversion}
	\caption[Aufbau der Inversion]{Aufbau der Inversion} %
	\label{fig:Gesamtinversion}
\end{figure} 

In \cite{deutNL} wird dafür die exakte Zustandslinearisierung eingeführt. Hier wird dem nichtlinearen System eine Inversion vorgeschaltet. Diese beinhaltet ein linearisierendes Stellgesetz, sodass sich das zu regelnde System für jeden Ausgang als entkoppelt und lineare Integrierekette darstellt. 
Die Herleitung eines solchen Stellgesetz ist mathematisch sehr komplex und anspruchsvoll. Der Grund, warum heutzutage viele Regelungen weiterhin basierend auf der Arbeitspunktlinearisierung entworfen werden.

%Betrachtet man die Modellstruktur für die translatorische Bewegung (Abbildung \ref{fig:modstrukquad}) so kann man erkennen, das für fiktive Eingänge $ u_f = \begin{bmatrix}
%a^n_x &
%a^n_y &
%y^n_z 
%\end{bmatrix}^T$ das Modell aus drei unabhängigen entkoppelten Integriererketten 2.Ordnung bestehen würde. Die per Definition der Linearität \cite{lunze08} ein lineares Zustandsverhalten aufweisen. Gesucht ist also ein Stellgesetz, das für die fiktiven Eingängen $ u_f $ die Stellgrößen der realen Eingänge $ u = \begin{bmatrix} 
%T  &
%\phi &
%\theta &
%\psi 
%
%\end{bmatrix} $ generiert. Eine sogenannte Inversion. \\
Exakte Zustandslinearisierung bedeutet für das Quadrocoptermodell (Kapitel \ref{sec:Modelbildung}), es ist ein Stellgesetz für $ u = \begin{bmatrix} T  &\phi &\theta &\psi \end{bmatrix} $ gesucht, welches das System für die Ausgänge $ y =  \begin{bmatrix} x & y & z \end{bmatrix} $ entkoppelt. Für die Positionsregelung stehen so die fiktiven Eingänge $u_f = \begin{bmatrix} a^n_x &	a^n_y & y^n_z \end{bmatrix}^T$ zur Verfügung. Das bedeutet, es können ohne Berücksichtigung der Orientierung des Quadrocopters Beschleunigungswerte im n-frame vorgegeben werden.

Damit eine solche Inversion für die Position als Ausgang $ y =  \begin{bmatrix}x & y & z \end{bmatrix} $ möglich ist, muss es sich bei diesem Ausgang um einen so genannten flachen Ausgang $ y_f = \begin{bmatrix} y_{f1} & y_{f2} & y_{f3} \end{bmatrix}$ handeln. 

%Vollständige Definition siehe Anhang \ref{anh:def_fl}.  
%Damit aus dem nichtlinearen Modell Kapitel \ref{sec:Modelbildung} ein Exakt zustandslinearisierendes Stellgesetz (Inversion) generiert werden kann, muss es sich bei dem Ausgang $ y =  \begin{bmatrix} 
%x &
%y &
%z &  
%\end{bmatrix} $  um einen sogenannten flachen Ausgang $ y_f = \begin{bmatrix} 
%y_{f1} &
%y_{f2} &
%y_{f3} 
%\end{bmatrix}$ handeln. 

Per Definition (Anhang \ref{anh:def_fl}) muss dafür das Kriterium, Anzahl der flachen Ausgänge $ p_y $ entsprechen der Anzahl der Eingänge $ p_u $ des nichtlinearen Systems, erfüllt sein. Dieses Kriterium ist für $ y_f = \begin{bmatrix} x & y & z \end{bmatrix}$ und die Eingangsgrößen $ u = \begin{bmatrix} T  & \phi & \theta & \psi \end{bmatrix} $ verletzt.
%kann es sich bei dem gewünschten flachen Ausgang $ y_f = \begin{bmatrix} 
%x &
%y &
%z 
%\end{bmatrix}$ nur um einen solchen Handeln wenn die Anzahl der flachen Ausgänge $ p $ derer der realen Eingänge $ u $ entspricht. Dies ist nicht der Fall.
Nach \cite{deutNL} heißt das, es muss ein neuer fiktiver Ausgang gesucht werden, sodass  $ p_y  = p_u$ gilt. Dieser neue Ausgang entspricht nicht mehr der Position. Das bedeutet, Positionsvorgaben müssen erst in die neuen Ausgänge transformierten werden. Auch der gewünschte fiktive Eingang der $u_f = \begin{bmatrix} a^n_x &	a^n_y & y^n_z \end{bmatrix}^T$ ist nicht mehr gegeben.

Aus diesem Grund bedient sich die in Kooperation mit AscTec entwickelte Inversion \cite{Achtelik11} einem Trick.  
% Damit dennoch eine Inversion durchgeführt werden kann, ist es möglich ein flacher Ausgang mit der selben Anzahl an Ausgängen wie Eingängen zu suchen. Dieser würde nicht mehr mit der Position $ P^n $ übereinstimmen. Deshalb wurde in Paper \cite{Achtelik11} ein anderer Weg eingeschlagen.  
Um die Position als flachen Ausgang zu erhalten, bedient man sich der Tatsache, dass eine Veränderung des $ \psi $-Winkels zu keiner Auslenkung des Schubvektors $ T $ führt. So können die Beschleunigungsvorgaben $ u_f $ über eine einfache Transformation (Gleichung \ref{eq:Mz}) um den Winkel $ \psi $ ins o-frame übertragen werden $\tilde{u}_f = \begin{bmatrix} a^o_x &	a^o_y & y^o_z \end{bmatrix}^T$. Gleiches gilt auch für den zugehörigen Ausgang $ y_f $. Demzufolge ergibt sich für diesen $\tilde{y}_f = \begin{bmatrix} y^o_{f1} &	y^o_{f2} & y^o_{f2} \end{bmatrix}$.Durch den Trick reduziert sich für die Inversion die Anzahl der Eingänge um einen. So entspricht die Anzahl der verbliebenen Eingängen $ \tilde{u} = \begin{bmatrix} \phi & \theta & T \end{bmatrix} $ denen des gewünschten flachen Ausgangs. Damit ist die Flachheit des Ausgangs $ \tilde{y}_f $ nicht vollständig erwiesen. Es fehlt per Definition (vgl. Anhang \ref{anh:def_fl}) der Beweis, dass sich alle Zustände $ \tilde{x} $ (vgl. Abbildung \ref{fig:modstrukquad}) und die reduzierten Eingänge $ \tilde{u} $ durch die flachen Ausgänge $ \tilde{y}_f $ und dessen Ableitungen darstellen lassen. Für die Zustände ist dieser Beweis ohne großen Rechenaufwand möglich.

\begin{equation}
\begin{split}
\tilde{y}^o_{f1} &= x^o = x_4 \\
\tilde{y}^o_{f2} &= y^o = x_5 \\
\tilde{y}^o_{f3} &= z^o = x_6 \\
\\\dot{\tilde{y}}^o_{f1} &= \dot{x}^o = x_1 \\
\dot{\tilde{y}}^o_{f2} &= \dot{x}^o = x_2 \\
\dot{\tilde{y}}^o_{f3} &= \dot{z}^o = x_3 
\end{split}
\end{equation}

Für die Eingangsgrößen $ \tilde{u} $ werden die Zustandsgleichungen für $ \dot{\tilde{x}}_1$, $ \dot{\tilde{x}}_2 $ und $ \dot{\tilde{x}}_3 $ (vgl. Gleichung \ref{eq:zstd}) nach $ \phi $, $ \theta $ und $ T $ aufgelöst. Dabei entspricht $ \dot{\tilde{x}}_1 = a^o_x = \ddot{\tilde{y}}_{f1} = \tilde{u}_{f1}$, $ \dot{\tilde{x}}_2 = a^o_y = \ddot{\tilde{y}}_{f2} = \tilde{u}_{f2}$ sowie $ \dot{\tilde{x}}_3 = a^o_z = \ddot{\tilde{y}}_{f3} = \tilde{u}_{f3}$. Damit wird der Schub $ T $ als Betrag der im o-frame wirkenden Kräfte, bzw. geforderten Beschleunigungen, multipliziert mit der Masse dargestellt.

\begin{equation}
\begin{split}
T &= m \cdot \sqrt{\ddot{\tilde{y}}_{f1}^2 +\ddot{\tilde{y}}_{f}^2+(\ddot{\tilde{y}}_{f3}+g )^2 }\\
&= m \cdot \sqrt{{a^o_x}^2 +{a^o_y}^2+(a^o_z+g)^2}
\end{split}
\label{eq:invT}
\end{equation}    

Da $ T $ bestimmt ist, ist unter Beachtung der vorgelagerten Transformation ($ \psi = 0 $),
%$ \psi = 0 $, $ \phi $ durch die vorgelagerte Transformation, 
$ \dot{\tilde{x}}_2 $ aus  Gleichung (\ref{eq:zstd}) nach  $ \phi $ aufzulösen. Damit ergibt sich:

\begin{equation}
\begin{split}
\phi &= -\arcsin(\frac{\ddot{\tilde{y}}_{f2}\cdot m}{T})\\
& = -\arcsin(\frac{a^o_y\cdot m}{T}).
\end{split}
\label{eq:invphi}
\end{equation}

$ \theta $ lässt sich aufgrund der trigonometrischen Beziehung $ tan\alpha = \frac{\sin\alpha}{\cos\alpha} $ aus den Zustandsgleichungen für $ \dot{\tilde{x}}_1 $ und $ \dot{\tilde{x}}_3 $ berechnen.
\begin{equation}
\begin{split}
\theta &= \arctan(\frac{\ddot{\tilde{y}}_{f1}}{\ddot{\tilde{y}}_{f3}+g})\\
&=\arctan(\frac{a^o_x}{a^o_z+g})
\end{split}
\label{eq:invtheta}
\end{equation}

\begin{figure}
	\centering
	\includegraphics[width = .85\textwidth]{images/3intket}
	\caption[Zustandslinearisiertes Translationsmodell]{Zustandslinearisiertes Translationsmodell} %
	\label{fig:drIntket}
\end{figure}

Die Stellgesetze der exakten Zustandslinearisierung sind damit über Gleichung (\ref{eq:invT}), (\ref{eq:invphi}) und (\ref{eq:invtheta}) mathematisch beschrieben. In Verbindung mit der Koordinatentransformation mittels $ \psi $ ergibt sich die in Abbildung \ref{fig:Gesamtinversion} dargestellte Inversion.

Die Richtigkeit lässt sich über eine Simulation beweisen (Abbildung \ref{fig:sim_inversion}). Das Modell besteht dabei aus Translationsmodell (Abbildung \ref{fig:modstrukquad}) und Inversion (Abbildung \ref{fig:Gesamtinversion}). Über den neuen Eingang $ u_f $ werden dabei Beschleunigungswerte im n-frame vorgegeben (Abbildung \ref{fig:inv_uf}). Unter Einfluss ständig wechselnder  
Orientierung um die Hochachse (Abbildung \ref{fig:inv_psi}) ergeben sich die in der Abbildung \ref{fig:inv_aso} dargestellten Vorgaben für das exakt zustandslinearisierende Stellgesetz. Die daraus resultierende Schubvorgabe (Abbildung \ref{fig:inv_T}) und Winkel (Abbildung \ref{fig:inv_phitheta}) werden dem Bewegungsmodell übergeben. Mit dem Ergebnis, dass die resultierenden Beschleunigungen des Modells den Beschleunigungsvorgaben entsprechen (Abbildung \ref{fig:inv_amdl}).

Dadurch ist das zu regelnde System als lineares Modell zu sehen, bestehend aus drei entkoppelten Integrierketten (Abbildung \ref{fig:drIntket}). Dieses System ist jedoch instabil. Das bedeutet für die Vorgabe einer konstanten Beschleunigung schwingt der Quadrocopter auf keiner konstanten Position ein, sondern Integriert seine Position immer weiter auf. Begründet ist dieses Verhalten auch durch das Weg-Zeit-Gesetz (Gleichung \ref{eq:weg-zeit}). Jedoch besteht die Möglichkeit einen Beschleunigungsverlauf vorzugeben, für den der Quadrocopter in eine neue Position überführt wird. Dafür wird eine Vorsteuerung benötigt.


 \begin{figure}
 	
 	\centering{
 		\subfloat[Fiktive Eingänge]{
 			\includegraphics[width=0.5\textwidth]{images/inv_uf}
 			\label{fig:inv_uf}
 		}
 		\subfloat[Orientierung um z-Achse]{
 			\includegraphics[width=0.5\textwidth]{images/inv_psi}
 			\label{fig:inv_psi}
 		}\\
 		\subfloat[Ins o-frame transformierte Beschleunigungsvorgaben]{
 			\includegraphics[width=0.5\textwidth]{images/inv_aso}
 			\label{fig:inv_aso}
 		}
 		\subfloat[Schubvorgabe der Inversion]{
 			\includegraphics[width=0.5\textwidth]{images/inv_T}
 			\label{fig:inv_T}
 		}\\
 		\subfloat[Winkelvorgabe der Inversion]{
 			\includegraphics[width=0.5\textwidth]{images/inv_phitheta}
 			\label{fig:inv_phitheta}
 		}
 			\subfloat[Beschleunigungswerte im Translationsmodell (vgl. Eingangsgrößen Abbildung \ref{fig:inv_uf})]{
 				\includegraphics[width=0.5\textwidth]{images/inv_amdl}
 				\label{fig:inv_amdl}
 			}
 	}	
 	\caption[Simulation der Inversion]{Simulation der Inversion}
 	\label{fig:sim_inversion}
 \end{figure}



\section[Referenzmodell]{Vorsteuerung mittels eines Referenzmodells}
\label{sec:referenzmodell}
Eine Vorsteuerung erzeugt anhand einer Sollwertvorgabe einen Stellgrößenverlauf, der erforderlich ist, um das System im störungsfreien Fall in diesen Zustand zu überführen. In \cite{Achtelik11} wird von einem Referenzmodell gesprochen. 
 
In Sachen Positionsregelung bedeutet das die Übergabe einer anzufliegende Position $ P^n_{cmd} $ anhand der die Vorsteuerung eine Trajektorie generiert. 
%Der Pfad $ P^n_{ref} $ mit dem der Quadrocopter in diesen Zustand überführt wird, muss dabei mindestens einmal stetig differenzierbar sein. 
Damit der Quadrocopter dem vorgegeben Pfad $ P^n_{ref} $ folgen kann, muss dessen Verlauf mindestens einmal stetig differenzierbar sein. Das bedeutet, die zweite Ableitung der Position $ \ddot{P}^n_{ref} $ und somit die Eingangsgröße $ U_f $ der Inversion muss mindestens stückweise existieren, sodass der Referenzpfad $ P^n_{ref} $ als auch die Referenzgeschwindigkeit $ \dot{P}^n_{ref} $ einen kontinuierlichen Verlauf aufweisen (Abbildung \ref{fig:tragen}).
%Der Grund, die Stellgrößen der Inversion sind Beschleunigungsvorgaben. 
%Der Grund, Position als auch die Geschwindigkeit des Referenzmodells müssen einen kontinuierlichen Verlauf aufweisen , damit der Quadrocopter dem Pfad folgen kann. 
%Demzufolge muss die zweite Ableitung der Position mindestens stückweise existieren. 
Damit dies gewährleistet ist, ist nach \cite{deutNL} folgende Differenzialgleichung für das Referenzmodell aufzustellen. 

%Zur Vorgabe des gewünschte benötigt man als Vorsteuerung ein Referenzmodell. Diesem werden die anzufliegenden Positionen $ P^n_{cmd} $ übergeben. Aufgabe der Vorsteuerung ist es daraus eine Trajektorie zu generieren. Diese beschreibt den Pfad über den der Quadrocopter in diese Koordinate überführt wird. Da die neuen Eingangsgrößen $ u_f $ des zustandslinearisierten Modells Beschleunigungsvorgaben sind, muss der Verlauf der Positionsvorgabe der Vorsteuerung $ P^n_{ref} $ einmal stetig differenzierbar sein, sodass die zweite Ableitung existiert. Damit dies gewährleistet kann nach \cite{deutNL} die E/A Dynamik für dieses System über folgende Formel vorgegeben werden.

\begin{equation}
	\ddot{P}^n_{ref} + c_1 \cdot \dot{P}^n_{ref}+c_0\cdot P^n_{ref}=c_0 \cdot P^n_{cmd}
	\label{eq:dynref}
\end{equation}
Hierbei kann die Dynamik, mit der das Fluggerät überführt wird, über die Koeffizienten $ c_0 $ und $ c_1 $ eingestellt werden. Stellt man für (\ref{eq:dynref}) die Übertragungsfunktion $ G(s) $ auf,
\begin{equation}
\begin{split}
G(s)=\frac{P^n_{ref}}{P^n_{cmd}} &=\frac{c_0}{s^2+c_1\cdot s+c_0}\\
&= \frac{1}{\frac{1}{c_o}s^2+\frac{c_1}{c_0}\cdot s+1}
\end{split}	
\label{eq:gsref}
\end{equation}
ist erkennbar, dass diese in ihrer Form einem PT2-Glied entspricht.
\begin{equation}
	G_{PT2}(s)=\frac{1}{(\frac{1}{\omega_o})^2s^2+\frac{2D}{\omega_0}\cdot s+1}
	\label{eq:gspt2}
\end{equation}

Setzt man (\ref{eq:gspt2}) mit (\ref{eq:gsref}) gleich, kann man die Koeffizienten $ c_0 $ und $ c_1 $ abhängig der gewünschten Eigenfrequenz $ \omega_0 $ und Dämpfung $ D $ wählen.
\begin{equation}
c_0= \omega_0^2
\label{eq:ref_c0}
\end{equation}
\begin{equation}
c_1= 2 D\omega_0
\label{eq:ref_c1}
\end{equation}
Der Vorteil ist, die Dynamik der Vorsteuerung ist über die in den Grundlagen der Regelungstechnik \cite{lunze08} vermittelten Entwurfskriterien für PT2-Glieder einstellbar.
Über $ \omega $ kann einstellen werden, wie schnell die Zielkoordinate erreicht wird. Das Wie, lässt sich über die Dämpfung $ D $ bestimmen. So wird für alle $ D \le 1 $ eine Pfad ohne Überschwinger generiert. 
Die Dynamikvorgabe ist durch die maximal zulässige Stellgröße beschränkt. Als Folge kann $ \omega $ nicht beliebig groß gewählt werden. 

Der Stellgrößenverlauf $ u_{f_{ref}} = \ddot{P}^n_{ref}  $ ist damit über (\ref{eq:dynref}) mit (\ref{eq:ref_c0}) und (\ref{eq:ref_c1}) folgendermaßen festgelegt.
\begin{equation}
u_{f_{ref}} = \omega_0^2 \cdot(P^n_{cmd}-P^n_{ref})-2D\omega_0\cdot \dot{P}^n_{ref}
\label{eq:ref_mdl}
\end{equation}
%Vorteil dieser Darstellung ist, das die Dynamik der Vorsteuerung über die in den Grundlagen der Regelungstechnik \cite{lunze08} vermittelten Entwurfskriterien für PT2-Glieder bestimmen lässt. So ist die Schwingungsfähigkeit über die Dämpfung $ D $ beeinflussbar ($ D \le 1 $, keine Schwingung). Mit $ \omega_0 $ kann schließlich eingestellt werden wie schnell die Zielkoordinaten erreicht werden sollen. $ \omega $ ist da bei durch die maximal zulässige Stellgröße beschränkt.
\begin{figure}
	\centering
	\includegraphics[width = \textwidth]{images/refmdl}
	\caption[Strukturbild der Vorsteuerung]{Strukturbild der Vorsteuerung} %
	\label{fig:strucref}
\end{figure}
Das resultierende Strukturbild der Vorsteuerung ist in Abbildung \ref{fig:strucref} visualisiert. Für eine Positionsverschiebung um $ 1~m $ erzeugt das Referenzmodell eine Trajektorie (Abbildung \ref{fig:tragen_pcmdref}-\ref{fig:tragen_vref}) bzw. den in Abbildung \ref{fig:tragen_aref} dargestellten Stellwertverlauf. Hier ist anzumerken, dass aufgrund der entkoppelten Integriererketten (Kapitel \ref{sec:exkt.zstdlin}) eine separate Dynamikvorgabe für jeden Zweig des zustandslinearisierten Modells möglich ist. 
 \begin{figure}
 	\centering{
 		\subfloat[Positionsvorgabe über $ p_{cmd} $ und generierte Positionsvorgabe $ p_{ref} $]{
 			\includegraphics[width=0.5\textwidth]{images/p_cmdref}
 			\label{fig:tragen_pcmdref}
 		}\\
 		\subfloat[Geschwindigkeitsvorgabe $ v_{ref} = \dot{p}_{ref} $ der Trajektorie]{
 			\includegraphics[width=0.5\textwidth]{images/v_ref}
 			\label{fig:tragen_vref}
 		}
 		\subfloat[Beschleunigungsvorgabe $ u_{f_{ref}} = a_{ref} = \ddot{p}_{ref}$]{
 			\includegraphics[width=0.5\textwidth]{images/a_ref}
 			\label{fig:tragen_aref}
 		}
 	}	
 	\caption[Simulationsergebnisse Referenzmodell]{Simulationsergebnis des Referenzmodells für eine Achse mit $ \omega_0 = 1.5~Hz$ $ D = 1 $}
\label{fig:tragen}
 \end{figure}
Weiterhin besteht die Option die Vorsteuerung auszubauen, so dass Geschwindigkeiten vorgegeben werden können. Dies erleichtert unter anderem das manuelle Navigieren mittels einer Fernsteuerung. Die Vorgabe der Geschwindigkeiten $ v^o_{cmd} $ erfolgt im o-frame. Diese wird anschließend ins n-frame transformiert und dort über die Zeit integriert. Es ergibt sich eine stetige Positionsvorgabe für $ P^n_{cmd} $. 

\begin{equation}
P^n_{cmd} = \int (M_z^T\cdot v^o_{cmd}) dt + P^n_{cmd_0}
\label{eq:v_Pcmd}
\end{equation}

Mit (\ref{eq:v_Pcmd}) wird das Referenzmodell (\ref{eq:ref_mdl}) gespeist. Daraus resultiert eine Stellgröße, für die der Quadrocopter der stetigen Positionsvorgabe (\ref{eq:v_Pcmd}) folgt. Die maximale Geschwindigkeit ist durch die Grenzfrequenz $ \omega_0 $ des Referenzmodells begrenzt. Je größer $ \omega_0 $ ist, desto höher die maximal mögliche Geschwindigkeit.
  
Die Vorsteuerung ist hiermit für alle Anwendungszwecke entworfen. Speist man das exakt zustandslinearisierte Stellgesetz mit den generierten Stellwertverläufen alle drei Achsen, so folgt das Modell des Quadrocopter der Trajektorie. Dies gilt nur für den Fall konsistenter Anfangszustände (Abbildung \ref{fig:vor_ohnestr}). Ist dies nicht gegeben, ist wie in Abbildung \ref{fig:vor_inkonAzust} zu erkennen, dass der Positionsverlauf des Translationsmodells für den gleichen Stellgrößenverlauf nicht der Referenz entspricht. Gleiches gilt für Unsicherheiten bei Modellparametern (Abbildung \ref{fig:vor_unsichmdlpara}). Hierbei berechnet die Inversion einen unzureichenden oder überdimensionierten Schubvektor. 
%Simuliert man das Modell (Abbildung \ref{fig:Gesamtinversion}) inklusive des Stellgesetzes der Vorsteuerung Gleichung (\ref{eq:ref_mdl}) für konsistente Anfangsbedingungen $ P_{ref0}^n = P_0^n $ so ergibt sich die gewünschte Flugkurve. In der Realität ist die Konsistens der Angfangsbedingungen jedoch nicht immer gegeben. 
Auch können äußere Kräfte, hervorgerufen durch z.B. Winde wirken, die den Quadrocopter von der Trajektorie ablenken. Um all diesen Effekten entgegenzuwirken ist ein Folgeregler notwendig. Dessen Aufgabe besteht darin, diese Einflüsse zu eliminieren, sodass der Modellverlauf im gestörten Fall der Trajektorie entspricht.
 \begin{figure}
 	\centering{
 		\subfloat[Konsistente Anfangszustände $ p_{ref_0}~=~p_{mdl_0}~=~0 $ und $ v_{ref_0}~=v_{mdl_0}~=~0 $]{
 			\includegraphics[width=0.5\textwidth]{images/vstr_ohnest}
 			\label{fig:vor_ohnestr}
 		}\\
 		\subfloat[Inkonsistene Anfangszustände $ p_{ref_0}~=~0~\ne~p_{mdl_0}~=~0.3 $ und $ v_{ref_0}~=~0~\ne~v_{mdl_0}~=~0.2 $]{
 			\includegraphics[width=0.5\textwidth]{images/p_p0_03_v0_02}
 			\label{fig:vor_inkonAzust}
 		}
 		\subfloat[Unsicherheit der Modellparamter $ m_{inv}~\ne~m_{mdl} $]{
 			\includegraphics[width=0.5\textwidth]{images/p_m_mdl_2_5}
 			\label{fig:vor_unsichmdlpara}
 		}
 	}	
 	\caption[Steuerung der Regelstrecke]{Steuerung der Reglestrecke mittels Stellgrößenverlauf der Vorsteuerung}
 	\label{fig:RefaliasVor}
\end{figure}
%++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section[Folgeregler]{Entwurf des Folgeregler}
\label{sec:folgeregeler}
Inkonsistente Anfangsbedingungen, externe Störungen sowie Modellunsicherheiten bewirken einen Ausgangsfolgefehler $e = P^n_{ref} - P^n $. Dieser pflanzt sich weiter fort, da es sich bei dem Stellsignal $  u_{f_{ref}} $ um eine Steuerung ohne Rückmeldung handelt. Der Quadrocopter folgt nicht der Trajektorie. Benötigt wird demzufolge ein Stellsignal $ u_f $, welches den Quadrocopter trotz Störeinfluss entlang der Trajektorie führt. Modellieren lässt sich die Fortpflanzung des Folgefehlers aufgrund des linearisierten Modells in Form einer doppelten Integriererkette. Ein solches System ist instabil \cite{lunze08}.
%Dieser ergibt sich durch die Fortpflanzung des für das reale System nicht ausreichenden Stellsignals $\ddot{e} = u_{f_{ref}} - u_f$. Das bedeutet, die Fehlerdynamik kann ebenfalls über eine zweifache Integriererkette modelliert werden. 
 Damit später die Flugbahn des Quadrocopter trotzdem mit der Solltrajektorie konvergiert, muss die Fehlerdynamik stabilisiert werden. 
%Dafür ist es von nöten, die Dynamik der Folgefehler vorgeben zu können. 
Zu diesem Zwecke werden die Zustandsgrößen des Ausgangsfolgefehlermodells zurückgeführt (Abbildung \ref{fig:rückfolgefeh}). Daraus ergibt sich für die Vorgabe, dass der Folgefehler $ e $ in einer endlichen Zeit gegen $ 0 $ strebt, folgende Differentialgleichung:
\begin{figure}
	\centering
	\includegraphics[width = \textwidth]{images/fehlermdl}
	\caption[Ausgangsfolgefehlermodell mit Zustandsrückführung]{Ausgangsfolgefehlermodell mit Zustandsrückführung} %
	\label{fig:rückfolgefeh}
\end{figure}
\begin{equation}
\ddot{e} + \tilde{c}_1 \cdot \dot{e}+ \tilde{c}_0\cdot e = 0
\label{eq:fehlerdyn}
\end{equation}
 Mit 
\begin{equation}
\begin{split}
e &= P^n_{ref} - P^n\\
\dot{e} &= \dot{P}^n_{ref}-\dot{P}^n\\
\ddot{e} &= u_{f_{ref}} - u_f
\end{split}
\end{equation}
Diese kann nach $ u_f $ umgestellt werden. Dadurch ergibt sich das nachfolgende Stellgesetz für die Eingangsgröße $ u_f $ des zustandslinearsierenten Systems, welches den Folgefehler ausregelt. 
\begin{equation}
u_f = \underset{Vorsteuerung}{u_{f_{ref}}}+ \underset{Folgeregler}{\tilde{c}_1 \cdot (\dot{P}^n_{ref}-\dot{P}^n) +\tilde{c}_0\cdot (P^n_{ref} - P^n)}
\end{equation}
Das Annäherungsverhalten ist abhängig von den Koeffizienten $ \tilde{c}_0 $ und $ \tilde{c}_1 $. Anhand von (\ref{eq:fehlerdyn}) lassen sich für diese mittels der Polvorgabe (Kapitel \ref{subsec:polvor}) die Dynamik vorgegeben.

Nicht bekämpft werden durch dieses Stellgesetz konstante Dauerstörungen. Hervorgerufen zum Beispiel durch Winde, die über einen längeren Zeitraum als konstant anzusehen sind. Mit einer konstanten Kraft wirken sie auf das Flugsystem. Beachtet man die von dieser Kraft hervorgerufenen Beschleunigungsbeitrag $ a_st $ in der Fehlerdifferenzialgleichung, 
\begin{equation}
\ddot{e} + \tilde{c}_1 \cdot \dot{e}+ \tilde{c}_0\cdot e +a_{st}= 0
\label{eq:fehlerdyn_st}
\end{equation}
folgt im stationären Zustand, d.h. alle Zeitableitungen gleich Null, ein dauerhafter Positionsfehler.
\begin{equation}
e = -\frac{a_{st}}{\tilde{c}_0}
\end{equation} 
Lösung dieses Problems ist nach \cite{deutNL} die Erweiterung des Folgereglers mit einer integrierenden Komponente.
\begin{equation}
\ddot{e} + \tilde{c}_1 \cdot \dot{e}+ \tilde{c}_0\cdot e + \underset{I-Anteil}{\tilde{c}_{-1} \int e(\tau)d\tau} +a_{st}= 0
\label{eq:integodif}
\end{equation} 
Der I-Anteil liefert ein Signalanteil zur Kompensation der Störung im stationären Zustand. Den Beweis dafür erhält man, wenn man die Integro-Differentialgleichung (\ref{eq:integodif}) nach der Zeit ableitet. Daraus ergibt sich folgende Differentialgleichung. 
\begin{equation}
	\dddot{e} + \tilde{c}_1 \cdot \ddot{e}+ \tilde{c}_0\cdot \dot{e} + \tilde{c}_{-1} \cdot e = 0
	\label{eq:ifehlerdyn}
\end{equation}
Im eingeschwungenen Zustand  ist somit der Positionsfehler eliminiert. 
\begin{equation}
 e = 0
\end{equation}
Das Stellgesetz für einen Regler mit I-Anteil lässt sich unter Nichtbeachtung der Dauerstörung $ a_{st} $ aus Gleichung (\ref{eq:integodif}) entwickeln (vgl. Abbildung \ref{fig:folgeregler}).
\begin{equation}
u_f = \underset{Vorsteuerung}{u_{f_{ref}}}+ \underset{Folgeregler\ inklusive\ I-Anteil}{\tilde{c}_1 \cdot (\dot{P}^n_{ref}-\dot{P}^n) +\tilde{c}_0\cdot (P^n_{ref} - P^n)+\tilde{c}_{-1} \int e(\tau)d\tau}
\label{eq:folgreg_stelgeI}
\end{equation}
\begin{figure}
	\centering
	\includegraphics[width = 0.75\textwidth]{images/folgreg}
	\caption[Strukturbild des Folgereglers]{Strukturbild des Folgereglers} %
	\label{fig:folgeregler}
\end{figure}
Dieses Stellgesetz führt den Quadrocopter entlang der Referenztrajektorie. Zu erkennen ist dies in der Simulation (Abbildung \ref{fig:folg_RefaliasVor}) mit Regler. So wird für inkonsistente Anfangsbedingungen (Abbildung \ref{fig:folg_inkonAzust}) das Fluggerät auf die Trajektorie zurückgeführt. Für Modellunsicherheiten (Abbildung \ref{fig:folg_unsichmdlpara}) passt der Folgeregler das Stellsignal so an, dass der Quadrocopter entlang des vorgegebenen Pfades fliegt.

Wie zuvor kann das Einschwingverhalten für den Folgeregler mit I-Anteil über die Polvorgabe festgelegt werden. Für diesen Fall ist die Differentialgleichung (\ref{eq:ifehlerdyn}) zu verwenden. 
 \begin{figure}
 	\centering{
 		
 		\subfloat[Inkonsistene Anfangszustände $ p_{ref_0}~=~0~\ne~p_{mdl_0}~=~0.3 $ und $ v_{ref_0}~=~0~\ne~v_{mdl_0}~=~0.2 $, ideales Modell]{
 			\includegraphics[width=0.5\textwidth]{images/p_p0_03_v0_02_Kd_4_Kp_5_Ki_001}
 			\label{fig:folg_inkonAzust}
 		}
 		\subfloat[Unsicherheit der Modellparamter $ m_{inv}=1.863~\ne~m_{mdl}=2.5 $]{
 			\includegraphics[width=0.5\textwidth]{images/p_m_mdl_2_5_Kd_4_Kp_5_Ki_001}
 			\label{fig:folg_unsichmdlpara}
 		}
 	}	
 	\caption[Simulationsergebnisse mit Folgeregler]{Auswirkung von Folgeregler ($\tilde{c}_1=4$, $\tilde{c}_0=4$, $\tilde{c}_{-1}=0.01 $) auf inkonsistente Anfangszustände und Modellunsicherheiten }
 	\label{fig:folg_RefaliasVor}
 \end{figure}
 
 
 %++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Einstellung Dynamik mittels Polvorgabe}
\label{subsec:polvor}
Anhand der Lage der Polstellen einer Übertragungsfunktion lassen sich Rückschlüsse über Stabilität und Einschwingverhalten treffen. Ziel einer Zustandsregelung, wie der Folgeregelung, ist die Pollagen der zu regelnden Strecke so zu verschieben, dass das Ein-/Ausgangsverhalten die gewünschte Dynamik aufweist.

Zunächst ist zu klären, was die Polstellenlage in der komplexen Ebene über das Verhalten aussagt. Dabei entspricht die Anzahl der Pole $ \lambda_i $ der Ordnung $ n $ des Systems.
\begin{figure}
	\centering
	\includegraphics[width = 0.75 \textwidth]{images/stabgeb}
	\caption[Stabilitätsgebiet]{Stabilitätsgebiet} %
	\label{fig:stabgeb}
\end{figure}
\begin{itemize}
	\item Befinden sich alle Pole $ \lambda_i $ links der Imaginärachse ($ Re(\lambda_i) < 0 $) ist das System asymptotisch stabil, ansonsten instabil (Abbildung \ref{fig:stabgeb}).
	\item Komplexe Pole tauchen nur in Form von Polpaaren auf. Ist ein komplexes Polpaar vorhanden, führt das System nach Anregung eine Schwingung aus. Befinden sich die Polpaare in der linken Halbebene des Imaginärteil, nimmt die Amplitude der Schwingung exponentiell ab.
	\item Je weiter links sich die Pole auf der reellen Achse befinden, desto schneller ist das System. 
	\item Bei mehreren Polstellen wird das Verhalten hauptsächlich über den Pol bzw. das Polpaar mit dem größten Realteil bestimmt. Sie werden deshalb als dominante Pole bezeichnet.
\end{itemize}
Betrachtet man eine beliebige Übertragungsfunktion im Bildbereich,
\begin{equation}
G_e(s) = \frac{Z(s)}{N(s)}
\label{eq:Ge}
\end{equation}  
entsprechen die Polstellen $ \lambda_i $ des Systems den Nullstellen $ s_i $ des Nennerpolynom.
\begin{equation}
N(s)=  s^n+c_{n-1} \cdot s^{n-1}+ \cdots + c_1 \cdot s+ c_0 = \prod\limits_{n}^{i=1} (s-\lambda_i)= 0
\label{eq:N}
\end{equation}
Das dynamische Verhalten lässt sich anhand dieser Pollage analysieren. Im Umkehrschluss kann die Dynamik für frei wählbare Koeffizienten des Nennerpolynoms über die Vorgabe von Polstellen $ \lambda_{si} $ über einen Koeffizientenvergleich erfolgen.
\begin{equation}
N(s)=  s^n+c_{n-1} \cdot s^{n-1}+ \cdots + c_1 \cdot s+ c_0 =\prod\limits_{n}^{i=1} (s-\lambda_{si}) 
\end{equation}
Somit ist es möglich über die Koeffizienten von (\ref{eq:fehlerdyn}) oder (\ref{eq:ifehlerdyn}) das Einschwingverhalten des Folgereglers mittels der Platzierung von Polen vorzugeben. Wie jedoch die Polstellen optimal bestimmt werden, dafür gibt es keine generelle Vorgehensweise. In der Regel werden sie empirisch über Simulationen festgelegt, anschließend am realen Modell getestet und gegebenenfalls optimiert. Diese Optimierung geschieht meist händisch. Hier gibt es Bemühungen, diese letzte Optimierung am realen System zu automatisieren. 
  
\subsection{Automatische Optimierung der Reglerparameter}
\label{sec:selftun}
In der Simulation ermittelte Parameter müssen häufig für das reale System leicht angepasst werden, mit dem Ziel die Abweichung von der Referenztrajektorie möglichst gering zu halten. Von Vorteil ist es deshalb, einen Algorithmus zu implementieren, der kontinuierlich die Einstellung optimiert. Die Bezeichnung dieses Vorgangs heißt selftuning. 

Der implementierte Folgeregler inklusive I-Anteil setzt sich aus einem Proportionalverstärker $ P $, einem differentiellen Anteil $ D $ sowie einem Integrationsanteil $ I $ zusammen.
\begin{equation}
u_f = \underset{Vorsteuerung}{u_{f_{ref}}}+ \underset{D-Anteil}{\tilde{c}_1 \cdot (\dot{P}^n_{ref}-\dot{P}^n)} +\underset{P-Anteil}{\tilde{c}_0\cdot (P^n_{ref} - P^n)}+\underset{I-Anteil}{\tilde{c}_{-1} \int e(\tau)d\tau}
\end{equation}
Dadurch können Optimierungs-Algorithmen verwendet werden, die für einen PID-Regler entwickelt sind. Somit kann der unter \cite{selftun} vorgestellte Algorithmus angewendet werden. Dieser optimiert die Regelparameter über eine adaptive Interaktion. Diese besteht aus drei  folgenden Differentialgleichungen zur Anpassung der Koeffizienten des Reglers.
\begin{equation}
\begin{split}
\dot{k}_p &= \dot{\tilde{c}}_0 = \gamma \cdot e^2\\
\dot{k}_i &= \dot{\tilde{c}}_{-1} = \gamma \cdot e \cdot \int e(\tau)d\tau\\
\dot{k}_d &= \dot{\tilde{c}}_1 = \gamma \cdot e\cdot \dot{e}
\end{split}
\end{equation} 
\begin{figure}
	\centering
	\includegraphics[width = \textwidth]{images/selftune}
	\caption[Folgeregler inklusive Selftuning]{Folgeregler inklusive Selftuning} %
	\label{fig:selftun}
\end{figure}

Dabei entspricht $ \gamma $ dem Anpassungskoeffizient. In \cite{selftun} wird $ \gamma = 10 $ empfohlen. Die Struktur des sich daraus ergebenden Folgeregler mit Selbstoptimierung ist in Abbildung \ref{fig:selftun} dargestellt. Anzumerken ist, dass die Qualität der Optimierung von zu Beginn übergebenen Parametern abhängt. Die zuvor mittels der Polvorgabe (Kapitel \ref{subsec:polvor}) bestimmt werden. 

Im beschränkten Zeitraum der Arbeit konnte dieser Algorithmus nicht ausreichend untersucht und umgesetzt werden. Die im beschreiben Paper \cite{selftun} veröffentlichen Ergebnis des Optimierungsalgorithmus legen jedoch eine weiterführende Untersuchung dieses Teilbereichs im Anschluss dieses Ausarbeitung nahe.

\section[Zustandsschätzung]{Ermittlung der Zustände}
\label{sec:Zustandsbestimmung}

Bei der Folgeregelung handelt es sich um einen Zustandsregler. 
%Das bedeutet die Werte aller Zustände des realen Systems müssen bekannt sein. 
Unter Betrachtung des Stellgesetz (\ref{eq:folgreg_stelgeI}) für den Folgereglers geht hervor, dass die Position $ P^n $ als auch die Geschwindigkeit $ v^n $ mit der sich der Quadrocopter im n-frame bewegt zur Verfügung stehen müssen. Bereits bekannt ist, dass die Position $ P^n $ mittels des Lasers (Kapitel \ref{sec:laser_scan_matching}) bestimmt wird. Die Updaterate beträgt hier lediglich $ 40~Hz $.
%Die Position $ P^n $ ist bereits über den Laser (Kapitel \ref{chap:2Dpositionsbestimmung}) bestimmt. 
%Besitzt allerdings nur eine Updaterate von $ 40 Hz $.
 Daher ist es sinnvoll Zwischenwerte zu schätzen, so dass die Positionsdaten dem Folgeregler in einer höheren Taktrate bereitstehen. 
 
 Der Zustand der Geschwindigkeit $ v^n $ ist messtechnisch sehr schwer ermittelbar. Eine Möglichkeit zur messtechnischen Erfassung ist die Integration eines Dopplerradars \cite{ras12} auf dem Quadrocopter, der auf dem Doppler-Effekt basiert. Dabei wird ein periodisches Signal ausgesendet und je nach Geschwindigkeit verkleinert sich die Periodendauer, bzw. vergrößert sich für negative Geschwindigkeiten. So kann anhand der Frequenzänderung des reflektierten Signals auf die Geschwindigkeit geschlossen werden. Diese Umsetzung bedeutet die Integration eines weiteren Sensor. Aus Gewichts- und Kostengründen sind deshalb Methoden gefragt, die über die vorhandene Sensorik (IMU und Laser) die Geschwindigkeit des Quadrocopters feststellen.

\subsection{Geschwindigkeitsbestimmung über Integration der Beschleunigungsdaten}
\label{subsec:Vimu}
Die \gls{imu} beinhaltet einen 3D-Bewegungssensor. Dieser nimmt die Beschleunigung in $ x^b $, $ y^b $ und $ z^b $-Achse des Quadrocopters auf und stellt die Messwerte mit einer Frequenz von $ 1~kHz $ ($ T_{imu}=1~ms $) zur Verfügung. Aufgrund des Weg-Zeit-Gesetzes (\ref{eq:weg-zeit}) lässt sich die Geschwindigkeit über die Integration der Beschleunigung bestimmen. Für den diskreten Fall lässt sich diese mittels des Euler-Verfahrens (\ref{eq:eulva}) approximieren. Zuvor werden dafür die Beschleunigungsmesswerte ins n-frame transformiert (\ref{eq:inverse_transM}).  
\begin{equation}
v^n_{k+1} = v^n_k + T_{imu} \cdot (M_{nb}\cdot a^b_k) = v^n_k + T_{imu}  \cdot a^n_k 
\label{eq:eulva}
\end{equation}
Auf diese Weise ist die Geschwindigkeit bestimmt. In der Praxis führt diese Methode allerdings zu keinem guten Ergebnis. Grund dafür ist das Sensorrauschen $ r_{a_k} $ sowie der Bias b, der trotz Initialisierung nicht vollständig zu eliminieren ist. Damit entspricht der Messwert $ a^b_k $ nicht der tatsächlichen Beschleunigung $ a^b_{k_{tat}} $.
\begin{equation}
a^b_k = a^b_{k_{tat}} +  r_{a_k}+b
\end{equation}  
Das Problem ist, dass der Fehler mit integriert wird. Damit driften geschätzte und reale Geschwindigkeit auseinander. Dadurch ist eine verlässliche Geschwindigkeitsbestimmung ausschließlich über die Inertialsensorik nicht gewährleistet. 

\subsection{Geschwindigkeitsbestimmung über die Ableitung der Positionsdaten}
\label{subsec:abpos}
Ebenfalls auf Basis des Weg-Zeit-Gesetzes (\ref{eq:weg-zeit}) bestimmt sich die Geschwindigkeit über die Ableitung der Quadrocopterpositionen.
%lässt sich die Geschwindigkeit aufgrund des Weg-Zeit-Gesetzes (\ref{eq:weg-zeit}) über Ableitung der Quadrocopterpositionen bestimmen. 
Da es sich bei den Positionsdaten um diskrete Werte handelt, lässt sich die Ableitung  anhand des Euler-Verfahrens (\ref{eq:eul}) approximieren.
\begin{equation}
P^n_k=P^n_{k-1}+T_l \cdot v^n_k 
\label{eq:eul}
\end{equation}
Für die Geschwindigkeit ergibt sich
\begin{equation}
v^n_k = \frac{P^n_k-P^n_{k-1}}{T_l}
\label{eq:v_eul}
\end{equation}
Die Abtastzeit $ T_l = 25~ms $ ($f_l = 40~Hz $) entspricht der Updaterate  der Scans des Lasers mit denen die Algorithmen der Positionsbestimmung gespeist werden. Bei der Approximation der Geschwindigkeit ist zu beachten, dass das Positionssignal aufgrund von Sensorrauschen von Laser und Gyroskope sowie der Varianz des \gls{icp}-Algorithmus eine Abweichung vom tatsächlichen Positionswert $ P^n_{k_{tat}} $ aufweist. Diese Abweichung ist nicht konstant und ist als Positionsrauschen $ r_{P_k} $ darzustellen. 
\begin{equation}
P^n_k = P^n_{k_{tat}}+r_{P_k}
\end{equation}
Dieses Positonsrauschen $ r_P $ überträgt sich auf die Geschwindigkeit. 
\begin{equation}
v^n_k = \frac{P^n_k-P^n_{k-1}}{T_l} + \frac{r_{P_k} -r_{P_{k-1}}}{T_l}
\label{eq:vn_diskabrau}
\end{equation} 
 Diese führt nicht dazu, dass wie bei der Geschwindigkeitsbestimmung mittels der Beschleunigungssensoren, der Schätzwert und Realwert auseinander divergieren. Nichtsdestotrotz besitzt das Rauschen einen Einfluss auf die Qualität der Geschwindigkeitsberechnung. So fällt bei niedrigen Geschwindigkeiten der Abstand zwischen zwei Positionswerten geringer aus. Der Betrag des Rauschanteils bleibt konstant. Dies führt vor allem bei Schwebeflügen sowie Flügen mit geringer Dynamik zu einer erhöhten Unsicherheit der Schätzung (Abbildung \ref{fig:VarPosVerschHohe}). Zwar zeigt die Grafik \ref{fig:VarPosVerschNierdrig}, dass der Einfluss des Rauschen auf die Varianz der errechneten Geschwindigkeit (\ref{eq:vn_diskabrau}) mit der Größe der Positionsverschiebung abnimmt. Ungeachtet dessen ist es gerade notwendig für Bewegungen mit geringer Geschwindigkeit den Einfluss des Positionsrauschens zu minimieren.  
 \begin{figure}
 	\centering{
 		\subfloat[Keine(geringe) Positionsverschiebung, hohe Varianz]{
 			\includegraphics[width=0.5\textwidth]{images/adapt_varklpos}
 			\label{fig:VarPosVerschHohe}
 		}
 		\subfloat[Große Positionsverschiebung, geringe Varianz]{
 			\includegraphics[width=0.5\textwidth]{images/adapt_vargrpos}
 			\label{fig:VarPosVerschNierdrig}
 		}
 	}	
 	\caption[Auswirkung der Positionsverschiebung auf Varianz der Geschwindigkeit]{Auswirkung der Positionsverschiebung auf Varianz der Geschwindigkeit}
 	\label{fig:VarPosVersch}
 \end{figure}
 Geht man davon aus, dass die Frequenz des Rauschanteils oberhalb des Frequenzbandes der Positionsänderungen liegt, kann das Nutzsignal mittels eines Tiefpassfilters vom Rauschanteil getrennt werden. Das Tiefpassfilter lässt sich dabei mittels eines rekursiven \gls{iir}-Filters realisieren \cite{des14}. Die gefilterte Geschwindigkeit $ \hat{v}^n_k $ hängt dabei nicht nur von den vorherigen Messwerten $v^n $, sondern auch von den vorherigen Filterergebnissen $ \hat{v}^n  $ ab.
 \begin{equation}
 \hat{v}^n_k = \sum\limits_{j = 0}^{n}a_j \cdot v^n_{k-j}+ \sum\limits_{i = 1}^{n}b_j \cdot \hat{v}^n_{k-i}
 \label{eq:filter}
 \end{equation}
 Mittels der Koeffizienten $ a_j $ und $ b_i $ wird das gewünschte Filterverhalten, zum Beispiel das eines Butterworth-Filters, mit der benötigten Grenzfrequenz realisiert. Die Ordnung $ n $ des Filter beschreibt wie viele der vorangegangenen Messwerten in die Filterung mit einzubeziehen sind. Beim Design des Filters werden jedoch Kompromisse zwischen Zeitverzögerung, Phasenverzerrung, Dämpfung und Stoppbandeigenschaften getroffen. Für die Folgeregelung ist es dabei wichtig, dass die beiden erstgenannten Kriterien möglichst gering ausfallen. Ist dies nicht der Fall, wirkt es destabilisierend auf den Regler. 
 
 Des Weiteren lassen sich aufgrund der geringen Updaterate von $ 40~Hz $ der Positionsdaten, die Dynamik des Quadrocopters und das Positionsrauschen spektral nicht eindeutig voneinander trennen. Unterdrückt man das Positionsrauschen werden auch schnelle Positionsänderungen des Quadrocoptes ausgefiltert. Für die hohe Dynamik des Quadrocopters ist die Anwendung eines Tiefpassfilter mit Grenzfrequenz nicht machbar. Gesucht ist eine Methode, die für Flüge mit geringer Dynamik die Varianz der Geschwindigkeitsschätzung, verursacht durch Positionsrauschen, möglichst stark verringert. Gleichzeitig jedoch der hohen Dynamik des Quadrocopters Folge leisten kann.  
 
 \subsection[Geschwindigkeitsbestimmung mittels der Methode des First-Order Adaptive Windowing]{Geschwindigkeitsbestimmung anhand der Positionsdaten mittels der Methode des First-Order Adaptive Windowing }
 \label{subsec:adaptwind}
 Wie in Kaptiel \ref{subsec:abpos} erläutert, nimmt die Varianz der Geschwindigkeitsschätzung ab, je weiter die Positionswerte auseinander liegen. Hierfür sei auf Abbildung \ref{fig:VarPosVersch} verwiesen. Der gleiche Effekt tritt auf, je mehr Abtastschritte $ n $ der für die Euler-Approximation verwendete Bezugspunkt $ P^n_{k-n} $ in der Vergangenheit liegt. 
 \begin{equation}
 \hat{v}^n_k = \frac{P^n_k-P^n_{k-n}}{nT_l}=\frac{1}{n} \sum\limits_{j = 0}^{n-1} \hat{v}^n_{k-j} 
 \label{eq:v_eul_n}
 \end{equation}
 Dabei ist die Verwendung der Bezugsposition $ P^n_{k-n} $ gleichzusetzen mit der Mittlung der letzten $ n $ Geschwindigkeitsschätzungen ($ v^n_k,v^n_{k-1},\cdots,v^n_{k-n} $) mittels (\ref{eq:v_eul}). Deshalb spricht man auch von Fensterung beziehungsweise Windowing. Siehe zur Veranschaulichung Abbildung~\ref{fig:Fensterung}. Vergrößert man das Fenster, besitzt das eine äquivalente Wirkung wie die Reduzierung der Abtastrate.
  \begin{figure}
  	\centering
  	\includegraphics[width = \textwidth]{images/wind_avg}
  	\caption[Fensterung (Windowing)]{Fensterung (Windowing)} %
  	\label{fig:Fensterung}
  \end{figure}
 Das Windowing verhält sich wie ein Filter. So führt ein großes Fenster bei geringen Dynamiken zu einer sehr präzisen Geschwindigkeitsschätzung durch Rauschunterdrückung. Schätzungen für hochfrequente Bewegungen des Quadrocopter werden jedoch stark gedämpft und zeitverzögert ausgegeben, womit die Verlässlichkeit der Schätzung abnimmt. Es wirkt ähnlich wie das Filter (\ref{eq:filter}). Allerdings mit dem Vorteil, dass das Filterverhalten nur über einen Parameter einstellbar ist, der Fenstergröße $ n $. So sollte das Window klein sein, wenn der Quadrocopter hochfrequente Änderungen der Bewegung vornimmt, damit die abrupten Geschwindigkeitsänderungen möglichst ungedämpft erfasst werden. Bei geringen Dynamiken soll die Fenstergröße jedoch zunehmen, wodurch der Einfluss des Positionsrauschens minimiert werden soll. 
   \begin{figure}
   	\centering
   	\includegraphics[width = \textwidth]{images/adapt_endfit}
   	\caption[End-fit \gls{foaw}]{End-fit FOAW} %
   	\label{fig:foaw}
   \end{figure}
 Dabei erfolgt die Anpassung der Fenstergröße online und für jeden Punkt abhängig der Achse des n-frame. Im Paper \cite{adaptWin} ist dafür die Methode des \gls{foaw} vorgestellt. Diese besagt, existiert eine Grade zwischen den Positionswerten $ p^n_k $ und $ p^n_{k-n} $ einer Achse, die alle $ n $ Punkte innerhalb einer Tolerenz $ \pm d $ schneidet, stellt die Steigung dieser und somit die Geschwindigkeit einen optimalen Kompromiss zwischen Rauschunterdrückung (Präzision) und Verlässlichkeit dar. Die möglichen Schätzwerte für die Geschwindigkeit, abhängig von der Fenstergröße $ n $ und der Toleranz $ d $, sind im folgenden Datensatz dargestellt.
 
 \begin{equation}
 \hat{v}_k \in [\frac{p^n_k-p^n_{k-n}}{n T_l}-\frac{2d}{n T_l}, \frac{p^n_k-p^n_{k-n}}{n T_l}-\frac{2d}{n T_l}]
 \end{equation}
  Die Toleranz $ d $ ist dabei durch den Betrag der maximalen Rauschabweichung festgelegt und als Konstante zu sehen.
 \begin{equation}
 d = ||r_{max}||
 \end{equation}
Zu erkennen ist, dass die Varianz der Schätzung für eine steigende Fenstergröße $ n $ abnimmt. Somit ist ausgehend von der aktuellen Position $ p^n_k $ die maximale mögliche Fenstergröße $ n = max\{1,2,3,\dots\} $ zu ermitteln, für die gilt:
\begin{equation}
|p^n_{k-i} - \hat{p}^n_{k-i}|\le d \hspace{1.5cm}\forall~ i \in \{1,2,\dots,n\}
\label{eq:toleranz}
\end{equation} 
Dabei entspricht $ \hat{p}^n_{k-i} $ den Punkten auf der approximierenden Geradengleichung.
\begin{equation}
\hat{p}^n_{k-i} = a_n + b_n \cdot(k-i) T_l
\label{eq:gradengl}
\end{equation}
In \cite{adaptWin} ist dazu ein iterativer Algorithmus zur Lösung dieses Problems beschrieben. Dabei sind die Parameter der Geradengleichung (\ref{eq:gradengl}) wie folgt parametriert.
\begin{equation}
a_n =\frac{k \cdot p^n_{k-i} + (n-k)p^n_{k}}{n}
\label{eq:a_n}
\end{equation}
\begin{equation}
b_n =\frac{p^n_{k} - p^n_{k-n}}{n T_l}
\label{eq:b_n}
\end{equation}



Da die Steigung $ b_n $ aus den zwei Rändern des Fensters gebildet wird, spricht man von der End-fit-\gls{foaw} (Abbildung \ref{fig:foaw}).  


Der Ablauf des Interations-Algorithmus sieht wie folgt aus.

\begin{itemize}
	\item \textbf{Schritt 1:} Man verschiebt die Zeitachse so, dass für den Zeitpunkt des neusten Wertes $ p^n_k $ gilt $ t_k = k\cdot T_l = 0 $. Die Folge ist eine vom Faktor $ k $ unabhängige Geradengleichung.
	\begin{equation}
	\hat{p}^n_{k-i} = a_n + b_n \cdot(-i) \cdot T_l
	\label{eq:gradengl_t0}
	\end{equation}
	Für die gilt,
	 \begin{equation}
	a_n = p^n_k
	\end{equation}
	und $ b_n  $ weiterhin über (\ref{eq:b_n}) berechnet wird. Vorteil, es muss jeweils nur die Steigung neu berechnet werden.
	\item \textbf{Schritt 2:} Fenstergröße j = 1.
	\item \textbf{Schritt 3:} Berechnung des Parameters $b_j $ (\ref{eq:b_n}) der Geradengleichung (\ref{eq:gradengl_t0}) in Abhängigkeit der Fenstergröße $ j $.
	\item \textbf{Schritt 4:} Überprüfung, ob die berechnete Gerade alle im Fester befindlichen Punkte $p^n_{k-i} i \in \{1,2,\dots,j\} $ innerhalb  der Toleranz passiert (Bedingung (\ref{eq:toleranz})). 
	\item \textbf{Schritt 5:} Ist Schritt 4 erfüllt, inkrementiere die Fenstergröße $ j =j+1 $ und gehe zu Schritt 2. Wenn Bedingung nicht erfüllt ist, ist die Steigung der vorhergegangen Geradengleichung als Schätzwert der Geschwindigkeit auszugeben. 
	\begin{equation}
	 \hat{v}_k = b_{j-1}=b_n
	\end{equation} 
	Die maximale Fenstergröße $ n $ entspricht für Position $ p^n_{k} $  somit $ n = j-1 $ 
\end{itemize} 

Dieser Vorgang wird für jede Aktualisierung  $ k = k+1 $ des Positionswert $ p^n_{k} $ neu gestartet. %Zur Veranschaulichung ist der Algorithmus noch einmal in einen Flussdiagramm (Abbildung \ref{fig:flussfoaw}) dargestellt.  
 %\begin{figure}
 %	\centering
 %	\includegraphics[width = \textwidth]{images/Platzhalter}
 %	\caption[Flussdiagramm \gls{foaw}]{Flussdiagramm \gls{foaw}} %
 %	\label{fig:flussfoaw}
% \end{figure}
 Die End-fit-\gls{foaw} verwendet für den Schätzvorgang die zwei Endpunkte des Fensters. In \cite{adaptWin} wird zur Verbesserung die Best-fit\gls{foaw} vorgestellt. Dabei wird die Steigung über die Methode der Summe kleinsten quadratischen Fehler bestimmt. Das bedeutet für die zeitnormierte Geradengleichung ist eine Steigung $ b_n $ gesucht, für die die Summe der Fehlerquadrat $ e^2 $ ein Minimum aufweist.  
 \begin{equation}
 e_{min}^2 = min \sum\limits_{i=0}^{n}(p^n_{k-i} - \hat{p}^n_{k-i})^2
 \label{eq:quade}
 \end{equation}
 mit
 \begin{equation}
\hat{p}^n_{k-i} = p^n_{k} - b_n \cdot i \cdot T_l 
 \end{equation}
Um das Minimum der Fehlergleichung (\ref{eq:quade}) in Abhängigkeit der Steigung bestimmen zu können, ist diese nach $ b_n $ abzuleiten. Da es sich um eine quadratische Gleichung handelt, weist der Fehler einen Tiefpunkt auf, wenn diese Ableitung Null ergibt.
\begin{equation}
\frac{d e^2}{d b_n}=0
\end{equation}
Löst man unter dieser Bedingung die Ableitung nach $ b_n $ auf. Erhält man die Steigung, die die Summe der kleinsten quadratischen Fehler aufweist.
\begin{equation}
b_n = \frac{(n\sum\limits_{ i=0}^{n}y_{k-1}-2\sum\limits_{i=0}^{n} i\cdot y_{k-1})\cdot 6 }{T_l n(n+1)(n+2)}
\label{eq:bn_bestfit}
\end{equation}
Nun ist die Steigung allgemeingültig für variable Fenstergrößen bestimmt. Die Umsetzung der best-fit-\gls{foaw} in der Software erfolgt nach dem gleichen Schema wie bei der end-fit-\gls{foaw}. Einziger Unterschied, zur Berechnung der Steigung $ b_n $ wird die Gleichung (\ref{eq:bn_bestfit}) verwendet. Das Ergebnis ist eine präzisere Schätzung bei gleichbleibender Zuverlässigkeit der Messung. Beide Methoden sind anfällig gegen sogenannte Outlier. Einzelne Signalwerte weisen einen höheren Fehler als die maximal durch das Rauschen verursachte Abweichung $ d $ auf. Outlier lassen sich sehr einfach durch ein robustes Abbruchkriterium in Schritt 4 bekämpfen. So gilt die Bedingung (\ref{eq:toleranz}) erst dann für nicht erfüllt, wenn zwei aufeinanderfolgende Werte dem Kriterium nicht gerecht sind. Erst dadurch wird die Vergrößerung des Fensters gestoppt. Diese Variante nennt sich best-fit-\gls{foaw}-R.
 \begin{figure}
 	
 	\centering{
 		\subfloat[Positionsignal]{
 			\includegraphics[width=0.5\textwidth]{images/adap_position}
 			\label{fig:adapt_pos}
 		}
 		\subfloat[Ableitung (Kapitel \ref{subsec:abpos}) vs. endfit-\gls{foaw}]{
 			\includegraphics[width=0.5\textwidth]{images/adap_dtvsendfit}
 			\label{fig:adapt_ablvsend}
 		}\\
 		\subfloat[endfit-\gls{foaw} vs. bestfit-\gls{foaw}]{
 			\includegraphics[width=0.5\textwidth]{images/adap_endfitvsbestfit}
 			\label{fig:adapt_endvsbest}
 		}
 		\subfloat[bestfit-\gls{foaw} vs. bestfit-R-\gls{foaw}]{
 			\includegraphics[width=0.5\textwidth]{images/adap_bestfitvsbestfitr}
 			\label{fig:adapt_bestvsbestr}
 		}
 		}
 		
 	\caption[Messergebnis für \gls{foaw}]{Vergleich der Filterergebnisse für \gls{foaw}}
 	\label{fig:adap_vergleich}
 \end{figure}



Die Methoden des \gls{foaw} bieten eine sehr gute Möglichkeit die Geschwindigkeit auf Basis eines verrauschten Positionssignals zu ermitteln. Problematisch ist allerdings die geringe Abtastrate von $ 40~Hz $ des Lasers. Schon bei Flügen mit mittlerer Dynamik führt das dazu, dass die Fenstergröße stark reduziert wird. Somit auch der Einfluss des Positionsrauschens stark zunimmt. Zu sehen ist dies auch in Abbildung \ref{fig:adap_vergleich}, wo die Methoden des FOAW anhand einer realen Messung miteinander verglichen werden. Als Folge kann selbst dieses Konzept, limitiert durch die Tastrate des Lasers, der Dynamik des Quadrocopters nicht folgen. Es ist klar, dass eine Methode benötigt wird, die die Position und die Geschwindigkeit in einer höheren Taktrate zur Verfügung stellt. Gleichzeit müssen beide Signale ausreichend rauschunterdrückt sein. 

 \subsection{Bestimmung der Zustände mittels eines Fusionsfilter}
 \label{subsec:Fusionsfilter}
 Wie aus den vorherigen Unterkapitel zur Zustandsschätzung erkennbar, wird keine der Methoden denen zuvor gestellten Ansprüche gerecht. So erfüllt die Integration der Beschleunigung (Kapitel \ref{subsec:Vimu}) zwar das Kriterium zur Erhöhung der Taktrate, da die Beschleunigungsmesswerte in einem Takt von $ 1 kHz $ zur Verfügung stehen. Durch den Bias des Beschleunigungssensors divergieren jedoch innerhalb kürzester Zeit die geschätzten Zustände von den realen Zuständen. Dieses Phänomen tritt bei den Anwendungen Kapitel \ref{subsec:abpos} und Kapitel \ref{subsec:adaptwind} nicht auf. Der Grund, sie beziehen sich auf die vom Laser berechneten Positionswerte. Die Abweichungen dieser Zustandswerte befinden sich in einem konstanten Rahmen um die tatsächliche Position. Dieses Positionsrauschen sorgt bei der Geschwindigkeitsschätzung über die Ableitung der Positionswerte dafür, dass das errechnete Geschwindigkeitssignal ebenfalls einen Rauschanteil aufweist. Diesen Rauschanteil zu minimieren ist Ziel der \gls{foaw} Methode. Aufgrund der geringen Abtastfrequenz von $ 40Hz  $ kann auch dieser Ansatz der hohen Dynamik nicht Folge leisten. Schon für geringe Dynamiken ist die Fenstergröße stark dezimiert und damit auch die Rauschunterdrückung. Das Ergebnis, Beschleunigungssensor der \gls{imu} und Laser bieten jeweils für sich keine zuverlässigen Zustandswerte. Abhilfe ist die Fusion beider Sensordaten mittels eines Fusionsfilters. Dabei sorgen die Beschleunigungswerte mit ihrer hohen Updaterate von $ 1 Khz $ für eine schnelle Reaktionsfähigkeit und tragen somit der Dynamik des Quadrocopters sorge. Die Positionsdaten des Laser indes verhindern ein Abdriften der Schätzwerte. Als Folge stellen sie die Zuverlässigkeit der Fusionsergebnisse sicher. 
 
Das auf dem \gls{hlp} implementierte Fusionsfilter basiert auf einem Luenberger Beobachter\cite{Achtelik11}. Dieser besteht aus einem linearen Streckenmodell, dessen Zustände $ \hat{x} $ mittels eines Korrekturterms ($ L\cdot (y-\hat{y})$) auf die Zustände $ x $ der Regelstrecke einschwingen. Die Zustandsdifferenzialgleichung eines Luenberger Beobachter stellt sich in allgemeiner Form  \cite{regB12} wie folgt dar.
\begin{equation}
\begin{split}
\dot{\hat{x}} &= A \cdot \hat{x}+ L \cdot (y-\hat{y}) + B \cdot u\\
\hat{y} &= C \cdot \hat{x}
\end{split}
\label{eq:algbeo}
\end{equation} 
Dabei entspricht $ A $ der Dynamikmatrix, $ B $ der Eingangsmatrix und $ C $ der Ausgangsmatrix des linearen Streckenmodells. Aufgrund der Inversion ist das Bewegungsmodell für jede Achse im n-frame als Integrationsglied 2.Ordnung gegeben (Abbildung \ref{fig:drIntket}). Dabei entsprechen die Eingangsgrößen $ u $ den ins n-frame transformierten Beschleunigungswerten der \gls{imu}. Da die Ketten entkoppelt sind, muss der Beobachter nicht für alle drei Ketten gleichzeitig entworfen werden. Es ist ausreichend ein Integrationsglied 2.Ordnung als Streckenmodell heranzuziehen. Weiterhin ist bekannt, dass die Beschleunigungswerte der \gls{imu} einen Bias $ b $ aufweisen. Um diese Störgröße zu berücksichtigen kann das Streckenmodell nach \cite{mzr13} wie in Abbildung \ref{fig:emod} erweitert werden.  
   \begin{figure}
   	\centering
   	\includegraphics[width = \textwidth]{images/erwModell}
   	\caption[Erweitertes Streckenmodell]{Erweitertes Streckenmodell} %
   	\label{fig:emod}
   \end{figure}
Dieses erweiterte Modell ist über die Zustandsdifferenzialgleichung (\ref{eq:emod}) beschrieben
\begin{equation}
\begin{split}
\dot{x} &= \underset{A}{\begin{bmatrix} 
	0&	1&	0\\
	0&  0&  1\\
	0&	0&  0
	\end{bmatrix}} \cdot x+ \underset{B}{\begin{bmatrix}
	0\\
	1\\
	0
	\end{bmatrix}} \cdot u\\
y &= \underset{C}{\begin{bmatrix}
	1& 0& 0
	\end{bmatrix}} \cdot x
\end{split}
\label{eq:emod}
\end{equation} 
mit,
\begin{equation}
\hat{x} = \begin{bmatrix}
p^n&	v^n& 	b
\end{bmatrix}^T
\end{equation}
Anhand von (\ref{eq:algbeo}) folgt daraus für den Beobachter.
\begin{equation}
\begin{split}
\dot{\hat{x}} &= \underset{A}{\begin{bmatrix} 
	0&	1&	0\\
	0&  0&  1\\
	0&	0&  0
	\end{bmatrix}} \cdot \hat{x}+ \underset{L}{\begin{bmatrix}
	l_1\\
	l_2\\
	l_3
	\end{bmatrix}} \cdot (y-\hat{y}) + \underset{B}{\begin{bmatrix}
	0\\
	1\\
	0
	\end{bmatrix}} \cdot u\\
\hat{y} &= \underset{C}{\begin{bmatrix}
	1& 0& 0
	\end{bmatrix}} \cdot \hat{x}
\end{split}
\label{eq:ewmodelbeo}
\end{equation} 
mit,
\begin{equation}
\hat{x} = \begin{bmatrix}
\hat{p}^n&	\hat{v}^n& 	\hat{b}
\end{bmatrix}^T
\end{equation}
 \begin{figure}
 	\centering
 	\includegraphics[width = \textwidth]{images/Beobachter}
 	\caption[Beobachter]{Strukturbild Beobachter} %
 	\label{fig:strucB}
 \end{figure}
Vorteil des erweiterten Beobachters (Abbildung \ref{fig:strucB}) ist, dass der Bias des Beschleunigungssensors ebenfalls geschätzt wird. Das sorgt dafür, dass die Zuverlässigkeit der für die Folgeregelung benötigten Zustände $ \hat{v} $ und $ \hat{p} $ steigt. 
Das Einschwingverhalten mit dem die Beobachterwerte $ \hat{x} $ auf die realen Zustände $ x $ konvergieren, lässt sich über die Beobachtermatrix $ L $ bestimmen. Da der Zustandsfehler $ \tilde{x} = x-\hat{x} $ gilt, ergibt sich für die Dynamik des Zustandsfehlers
\begin{equation}
\dot{\tilde{x}}=\dot{x}-\dot{\hat{x}}=(A-LC)\cdot \tilde{x}
\end{equation}
Um diese mittels Polvorgabe einstellen zu können, muss daraus das charakteristische Polynom gebildet werden \cite{regB12}.
\begin{equation} 
N(s)=\det(A-LC)
\end{equation}
ergibt für das erweitere Zustandsmodell (\ref{eq:ewmodelbeo}),
\begin{equation} 
N(s)=s^3+l_1\cdot s^2+l_2 \cdot s + l_3
\end{equation}
Anhand dieses Polynom sind Koeffizienten der Beobachtermatrix $ L $ nach Kapitel \ref{subsec:polvor} über Polvorgabe vorgebbar. 
 
 
 \begin{figure}
 	
 	\centering{
 		\subfloat[Einspeisung]{
 			\includegraphics[width=0.5\textwidth]{images/ua}
 			\label{fig:bo_ua}
 		}
 		\subfloat[Einschwingverhalten Bias]{
 			\includegraphics[width=0.5\textwidth]{images/bias}
 			\label{fig:bo_bias}
 		}\\
 			\subfloat[Beschleunigung]{
 				\includegraphics[width=0.5\textwidth]{images/beschl}
 				\label{fig:bo_beschl}
 			}
 			\subfloat[Geschwindigkeit]{
 				\includegraphics[width=0.5\textwidth]{images/geschw}
 				\label{fig:bo_geschw}
 			}\\
 			\subfloat[Position]{
 				\includegraphics[width=0.5\textwidth]{images/Position}
 				\label{fig:bo_pos}
 			}
 		}	
 	\caption[Simulation Beobachter]{Simulationsergebnisse für das Fusionsfilter}
 	\label{fig:bo_sim}
 \end{figure}
 
 
 
 Um Beispielhaft das Einschwingverhalten des Fusionsfilters für eine Bebachtermatrix mit $ L= \begin{bmatrix} 18 & 46 & 3.75 \end{bmatrix}^T $ aufzeigen zu können, wird das zustandslinearisierte Streckenmodell mit einem variierenden Beschleunigungssignal gespeist. Um dem Beobachter ein realistischen Beschleunigungswert zur Verfügung zustellen, wird diesem ein Signal mit überlagerten Rauschen und einem Bias zugeführt (Abbildung \ref{fig:bo_ua}). Auch das Positionsergebnis des Streckenmodells wird für das Fusionsfilter mit einem Rauschen beaufschlagt. Zusätzlich wird dieses verrauschte Positionssignal mit einer Frequenz von $ 40~Hz $ abgetastet, die der Abtastrate des Lasers entspricht. Mit diesen störbehafteten Eingangsgrößen wird der Beobachter gespeist. Abbildung \ref{fig:bo_bias} zeigt, wie der geschätzte Bias $ \hat{b} $ auf den invertierten Wert des Beschleunigungsoffset einschwingt. Auf diese Weise wird der Bias $ b $ kompensiert (Abbildung \ref{fig:bo_beschl}). In Abbildung \ref{fig:bo_geschw} ist deutlich zu erkennen, welchen Einfluss dies auf die Qualität der Geschwindigkeitsschätzung nimmt. Im Gesamtergebnis stellt die Datenfusion dem Folgeregler ein rauschreduziertes Geschwindigkeits- (Abbildung \ref{fig:bo_geschw}) als auch Positionssignal (Abbildung \ref{fig:bo_pos}) zur Verfügung, das obendrauf noch die Daten mit einer Taktrate von $ 1~kHz $ bereit stellt. In Sachen Zuverlässigkeit und Genauigkeit ist diese Methode allen vorher genannten Methodiken überlegen. Womit deren Sinnhaftigkeit zur Zustandsschätzung im Rahmen des asctec\_hl\_framework dargelegt ist. Im Ergebnis ist damit der letzte Bestandteil der Positionsregelung hergeleitet und verifiziert. 
 
 %Das resultierende Positionssignals Abbildung  wird ebenfalls dem Beobachter zugeführt. Bei der Simulation des Beobachters     
  
  
%  \begin{figure}
%  	
%  	\centering{
%  		\subfloat[Positionsignal]{
%  			\includegraphics[width=0.5\textwidth]{images/adap_position}
%  			\label{fig:bo_adapt_pos}
%  		}
%  		\subfloat[Ableitung (Kapitel \ref{subsec:abpos}) vs. Beobachter]{
%  			\includegraphics[width=0.5\textwidth]{images/obs_vxvsob}
%  			\label{fig:bo_dvdtvsbo}
%  		}
%  	}	
%  	\caption[Verbesserung des Fusionsfilter im Vergleich \gls{foaw}]{Verbesserung des Fusionsfilter im Vergleich \gls{foaw}}
%  	\label{fig:bo_sim}
%  \end{figure} 
 
 \section{Simulation der Positionsreglung}
 \label{sec:sim_posreg}
In den vorangegangen Unterkapiteln \ref{sec:exkt.zstdlin} bis \ref{sec:Zustandsbestimmung} wurden die einzelnen Komponenten der Positionsregelung durchleuchtet, deren Herleitung aufgezeigt und ihr Richtigkeit mittels eines Simulationsbeispiels dargelegt. Aufgabe dieses Kapitels ist es, die Funktionsfähigkeit des Gesamtsystems mittels einer Simulation zu beweisen.

Der Simulationsaufbau basiert auf dem in Kapitel \ref{sec:Modelbildung} eingeführten Bewegungsmodell des Quadrocopters. Um die Simulation möglichst realistisch zu gestalten sind die Ausgangsgrößen denen der Realität angenähert. So sind die Beschleunigungswerte als auch die Positionsdaten mit einem weißen Rauschen überlagert. Darüber hinaus, wird die Postion nur in einem diskreten Zeitintervall von $ T_l = 25~ms $ aktualisiert. Aus diesen Ausgangswerten interpoliert das Fusionsfilter die Positionsdaten und bestimmt den Zustand der Geschwindigkeit. Parametriert ist der Beobachter (Gleichung (\ref{eq:ewmodelbeo})) mit $ L= \begin{bmatrix} 18 & 46 & 3.75 \end{bmatrix}^T $. Die Eingangsgrößen des Bewegungsmodells bestehen aus der Schubvorgabe sowie den Winkeln zur Beschreibung der Orientierung  ($ u = \begin{bmatrix}T &\phi &\theta &\psi \end{bmatrix}^T $). Daran angeschlossen befindet sich die Inversion (Kapitel \ref{sec:exkt.zstdlin}), welche das System zustandslinearisiert, so dass als neue Eingangsgrößen die Beschleunigungsgrößen in Richtung der n-frame Koordinatensysteme vorgegeben werden. Die Vorgabe eines Beschleunigungsverlaufs zur Überführung des Modells in eine neue Position ist Aufgabe der Kapitel \ref{sec:referenzmodell} beschriebene Vorsteuerung. Diese ist in Form eines Referenzmodell realisiert und liefert zusätzlich Referenzwerte zum Pfad und des Geschwindigkeitsverlaufs. Die Dynamik (Gleichung (\ref{eq:ref_mdl})) mit der die Überführung statt findet, ist für die Simulation mit $ \omega =1.5  $ und  $ D = 1 $ festgelegt. Weichen Zustände des Bewegungsmodelles, ermittelt durch den Beobachter, von der vorgegeben Trajektorie des Referenzmodells ab, greift der lineare Folgeregler ein. Dieser sorgt dafür, das der simulierte Bewegungspfad des Quadrocopter mit dem des Referenzmodells konvergiert. Somit eliminiert er Modellunsicherheiten beim Entwurf der Positionsregelung sowie externe Störungen. Die Koeffizienten der mit einem I-Anteil ausgeführten Regelung (Gleichung (\ref{eq:folgreg_stelgeI})) sind mit $ \tilde{c}_1 = 4 $, $ \tilde{c}_0 = 5 $ und $ \tilde{c}_1 = 0.01 $ festgelegt.
 \begin{figure}
 	\centering
 	\includegraphics[width = .75 \textwidth]{images/gessim_xy}
 	\caption[Simulierte Positionsverschiebung des Quadrocopters]{Simulierte Positionsverschiebung des Quadrocopters} %
 	\label{fig:gessim_xy}
 \end{figure}
 
Simuliert wird eine Positionsverschiebung des Quadrocopters in der horizontalen Ebene des n-frames. Dabei wird das Modell vom Ursprung des Koordinatensystems in den Punkt $ x = - 2~m $ und $ y = 1~m $ überführt. In Abbildung \ref{fig:gessim_xy} ist das dazugehörige Simulationsergebnis dargestellt. Dort ist zu sehen, wie das Bewegungsmodell entlang des vorgegebenen Pfades in die neue Koordinate übergeführt wird. Zu erkennen ist, dass trotz der filternden Wirkung des Beobachters der Einfluss des Rauschen als auch der niederfrequenten Abtastung nicht vollständig eliminiert wird. Der zeitliche Verlauf der Zustände dieses simulierten Anflugs der neuen Koordinate ist in Abbildung \ref{fig:gessim} separat für die x- und y-Achse dargelegt. Da die Simulation auf eine Variation des $ \psi $ Winkels verzichtet und damit die Orientierung des o-frames mit der des n-frames über den Simulationszeitraum übereinstimmt, können die Neigungswinkel des Quadrocopters einer Achsebewegung des n-frames zugeordnet werden. Somit ist der eingestellte Nickwinkel $ \theta $ (Abbildung \ref{fig:gessim_theta}) für die Bewegung auf der x-Achse, bzw. der Rollwinkel $ \phi $ (Abbildung \ref{fig:gessim_phi}) für die Bewegung auf der y-Achse ausschlaggebende Größe. Dabei ist in beiden Verläufen (Abbildung \ref{fig:gessim_phi} und \ref{fig:gessim_theta}) zu erkennen, dass sich im Zeitpunkt der Übergabe des neuen Positionswert die Winkel sprunghaft ändern. Das liegt daran, dass die Winkel mittels der Inversion aus den Beschleunigungsvorgaben bestimmt werden. Aufgrund der Stetigkeitsbedingung mit der die Vorsteuerung  entworfen ist(Kapitel \ref{sec:referenzmodell}), müssen die Beschleunigungsvorgaben nur stückweise existieren, das bedeutet diese können sich sprungartig ändern. Da zudem in der Simulation die Zeitkonstanten der Lageregelung vernachlässigt sind, folgt das Bewegungsmodell der Vorgabe eins zu eins.

Alles in allem zeigen die Simulationsergebnisse, dass die Regelung in der Theorie die an sie gestellten Ansprüche erfüllt. Um die Positionsregelung abschließend verifizieren zu können, ist deren Funktionsfähigkeit auf dem realen Quadrocopter zu untersuchen. 

 
  \begin{figure}
  	
  	\centering{
  		\subfloat[Position x-Achse]{
  			\includegraphics[width=0.5\textwidth]{images/gessim_pos_x}
  			\label{fig:gessim_pos_x}
  		}
  		\subfloat[Position y-Achse]{
  			\includegraphics[width=0.5\textwidth]{images/gessim_pos_y}
  			\label{fig:gessim_pos_y}
  		}\\
  		\subfloat[Geschwindigkeit x-Achse]{
  			\includegraphics[width=0.5\textwidth]{images/gessim_vel_x}
  			\label{fig:gessim_vel_x}
  		}
  		\subfloat[Geschwindigkeit y-Achse]{
  			\includegraphics[width=0.5\textwidth]{images/gessim_vel_y}
  			\label{fig:gessim_vel_y}
  		}\\
  		\subfloat[Nickwinkel]{
  			\includegraphics[width=0.5\textwidth]{images/gessim_theta}
  			\label{fig:gessim_theta}
  		}
  		\subfloat[Rollwinkel]{
  			\includegraphics[width=0.5\textwidth]{images/gessim_phi}
  			\label{fig:gessim_phi}
  		}
  	}	
  	\caption[Simulation Gesamtmodell]{Simulationsergebnisse des Gesamtmodells}
  	\label{fig:gessim}
  \end{figure}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  